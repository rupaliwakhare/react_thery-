


Hooks are one of the most powerful and transformative features in React. Introduced in React 16.8, they allow you to use state, lifecycle methods, and other React features in functional components, which were previously only available in class components.

ðŸª What Are Hooks?
Hooks are special functions that let you â€œhook intoâ€ React features. They simplify component logic and promote cleaner, more reusable code.

ðŸ”‘ Commonly  Used React Hooks

Hook Name	                                      Purpose	                                                 Example Usage
useState	                             Adds state to functional components	                             const [count, setCount] = useState(0)
useEffect	                             Performs side effects (e.g., data fetching, subscriptions)	       useEffect(() => { ... }, [deps])
useContext	                           Accesses context values without nesting	                         const value = useContext(MyContext)
useRef	                               Creates a mutable reference that persists across renders	         const inputRef = useRef(null)
useMemo	                               Memoizes expensive calculations	                                 const result = useMemo(() => compute(), [deps])
useCallback	                           Memoizes functions to prevent unnecessary re-renders	             const memoFn = useCallback(() => {}, [deps])
useReducer	                           Manages complex state logic (like Redux)	                         const [state, dispatch] = useReducer(reducer, initialState)



ðŸ“¦ Example: useState and useEffect

jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}




âš ï¸ Rules of Hooks
Only call hooks at the top level â€“ donâ€™t call them inside loops, conditions, or nested functions.

Only call hooks from React functions â€“ use them in functional components or custom hooks.

ðŸ§ª Custom Hooks
You can create your own hooks to reuse logic across components.

jsx
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return width;
}




ðŸ§© Types in Hooks


React Hooks come in several types, each serving a specific purposeâ€”from managing state and side effects to optimizing performance and accessing context. Here's a breakdown of the main types of hooks:

ðŸ§  1. State Management Hooks
These hooks help you manage and update state in functional components.

Hook	                                         Purpose	                                          Example
useState	                              Adds local state to a component	const                  [count, setCount] = useState(0)
useReducer	                            Manages complex state logic (like Redux)	             const [state, dispatch] = useReducer(reducer, initialState)


ðŸ” 2. Side Effect Hooks
Used to handle side effects like data fetching, subscriptions, or DOM updates.

Hook	                            Purpose	                                                            Example
useEffect	                       Runs code after render or when dependencies change	                 useEffect(() => {...}, [deps])


ðŸŒ 3. Context Hooks
Used to access and share global data across components.

Hook	                                Purpose	                             Example
useContext	                    Accesses context values	                const theme = useContext(ThemeContext)



ðŸ“Œ 4. Ref and DOM Hooks
Used to interact with DOM elements or persist values across renders without causing re-renders.

Hook                                         	Purpose                                       	           Example
useRef	                             Creates a mutable reference	                                       const inputRef = useRef(null)
useImperativeHandle	                Customizes the instance value exposed to parent via rerf             Used with forwardRef



âš™ï¸ 5. Performance Optimization Hooks
Used to memoize values or functions to avoid unnecessary re-renders.

Hook	                                   Purpose                                    	Example

useMemo	                        Memoizes expensive calculations	                 const result = useMemo(() => compute(), [deps])
useCallback	                   Memoizes functions	                               const memoFn = useCallback(() => {}, [deps])




ðŸ§ª 6. Custom Hooks
You can create your own hooks to encapsulate reusable logic.



jsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleStatusChange = () => setIsOnline(navigator.onLine);
    window.addEventListener('online', handleStatusChange);
    window.addEventListener('offline', handleStatusChange);
    return () => {
      window.removeEventListener('online', handleStatusChange);
      window.removeEventListener('offline', handleStatusChange);
    };
  }, []);

  return isOnline;
}