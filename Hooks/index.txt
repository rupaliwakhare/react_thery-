


Hooks are one of the most powerful and transformative features in React. Introduced in React 16.8, they allow you to use state, lifecycle methods, and other React features in functional components, which were previously only available in class components.

🪝 What Are Hooks?
Hooks are special functions that let you “hook into” React features. They simplify component logic and promote cleaner, more reusable code.

🔑 Commonly  Used React Hooks

Hook Name	                                      Purpose	                                                 Example Usage
useState	                             Adds state to functional components	                             const [count, setCount] = useState(0)
useEffect	                             Performs side effects (e.g., data fetching, subscriptions)	       useEffect(() => { ... }, [deps])
useContext	                           Accesses context values without nesting	                         const value = useContext(MyContext)
useRef	                               Creates a mutable reference that persists across renders	         const inputRef = useRef(null)
useMemo	                               Memoizes expensive calculations	                                 const result = useMemo(() => compute(), [deps])
useCallback	                           Memoizes functions to prevent unnecessary re-renders	             const memoFn = useCallback(() => {}, [deps])
useReducer	                           Manages complex state logic (like Redux)	                         const [state, dispatch] = useReducer(reducer, initialState)



📦 Example: useState and useEffect

jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}




⚠️ Rules of Hooks
Only call hooks at the top level – don’t call them inside loops, conditions, or nested functions.

Only call hooks from React functions – use them in functional components or custom hooks.

🧪 Custom Hooks
You can create your own hooks to reuse logic across components.

jsx
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return width;
}




🧩 Types in Hooks


React Hooks come in several types, each serving a specific purpose—from managing state and side effects to optimizing performance and accessing context. Here's a breakdown of the main types of hooks:

🧠 1. State Management Hooks
These hooks help you manage and update state in functional components.

Hook	                                         Purpose	                                          Example
useState	                              Adds local state to a component	const                  [count, setCount] = useState(0)
useReducer	                            Manages complex state logic (like Redux)	             const [state, dispatch] = useReducer(reducer, initialState)


🔁 2. Side Effect Hooks
Used to handle side effects like data fetching, subscriptions, or DOM updates.

Hook	                            Purpose	                                                            Example
useEffect	                       Runs code after render or when dependencies change	                 useEffect(() => {...}, [deps])


🌐 3. Context Hooks
Used to access and share global data across components.

Hook	                                Purpose	                             Example
useContext	                    Accesses context values	                const theme = useContext(ThemeContext)



📌 4. Ref and DOM Hooks
Used to interact with DOM elements or persist values across renders without causing re-renders.

Hook                                         	Purpose                                       	           Example
useRef	                             Creates a mutable reference	                                       const inputRef = useRef(null)
useImperativeHandle	                Customizes the instance value exposed to parent via rerf             Used with forwardRef



⚙️ 5. Performance Optimization Hooks
Used to memoize values or functions to avoid unnecessary re-renders.

Hook	                                   Purpose                                    	Example

useMemo	                        Memoizes expensive calculations	                 const result = useMemo(() => compute(), [deps])
useCallback	                   Memoizes functions	                               const memoFn = useCallback(() => {}, [deps])




🧪 6. Custom Hooks
You can create your own hooks to encapsulate reusable logic.



jsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleStatusChange = () => setIsOnline(navigator.onLine);
    window.addEventListener('online', handleStatusChange);
    window.addEventListener('offline', handleStatusChange);
    return () => {
      window.removeEventListener('online', handleStatusChange);
      window.removeEventListener('offline', handleStatusChange);
    };
  }, []);

  return isOnline;
}



advantages of Hooks

React Hooks revolutionized how developers write components by making functional components just as powerful as class components—often more so. Here are the key advantages of using Hooks in React:

🌟 1. Simplified Code Structure
No need for class components or this keyword.

Functional components are easier to read, write, and maintain.

Encourages cleaner and more concise code.

jsx
// Before (Class)
class Counter extends React.Component {
  state = { count: 0 };
  render() {
    return <button onClick={() => this.setState({ count: this.state.count + 1 })}>{this.state.count}</button>;
  }
}

// After (Hook)
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
🔄 2. State and Lifecycle in Functional Components
Hooks like useState and useEffect bring state and lifecycle features to functional components.

No need to switch between class and function components.

🔁 3. Reusable Logic with Custom Hooks
Extract and reuse logic across multiple components.

Promotes modularity and separation of concerns.

jsx
function useFetch(url) {
  const [data, setData] = useState(null);
  useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);
  return data;
}
⚡ 4. Improved Performance Optimization
Hooks like useMemo and useCallback help prevent unnecessary re-renders.

Fine-tune performance without complex class-based patterns.

🧠 5. Better Code Organization
Logic related to a feature can be grouped together in one place.

Avoids splitting lifecycle methods across different parts of a class.

🧪 6. Enhanced Testing and Debugging
Functional components with hooks are easier to test.

Less boilerplate and more predictable behavior.

🔧 7. Smaller Component Footprint
Functional components are generally lighter and faster.

Reduced memory usage and faster rendering.

🌐 8. Community and Ecosystem Support
Most modern React libraries and tools are built with hooks in mind.

Easier integration with third-party tools and state management libraries like Zustand or React Query.